# KTDDE Purchase Order Data Elements and GS1 Web Vocabulary Candidates

| Data element | TDED UID | KTDDE class (SHACL target) | KTDDE property (sh:path) | GS1 Web Vocabulary candidate(s) | Assessment of GS1 mapping |
|---|---|---|---|---|---|
| Purchase Order number | 1022 | `ktddecv:PurchaseOrder` | `ktddecv:orderIdentifier` | No direct `gs1:` property. Conceptually related code: `gs1:TransactionType-ON` (“Buyer Order Number”) as a message type code, not an identifier property. | **Weak / none** – GS1 encodes “order number” as transaction type codes, not as a generic identifier property you can map to `orderIdentifier`. |
| Contract number | 1296 | `ktddecv:Contract` | `ktddecv:contractIdentifier` | No direct contract-ID term in GS1 voc; only roles like `gs1:ContactRoleType-CONTRACT_CONTACT`. | **None** – GS1 does not really model contractual references at the same granularity. |
| Order date | 2011 | `ktddecv:PurchaseOrder` | `ktddecv:orderDate` | No `gs1:orderDate`. In practice, this would align with `schema:orderDate` (GS1 profiles schema.org), but that is not a `gs1:` term. | **Close but via schema.org, not GS1** – you can use `schema:orderDate` alongside GS1, but there is no GS1-native equivalent. |
| Delivery date | 2138 | `ktddecv:Consignment` | `ktddecv:deliveryDate` | No explicit `gs1:deliveryDate`. Delivery-related timing in GS1 is expressed via various availability/lead-time properties, not a single property. | **No direct GS1 property** – you would need a pattern using delivery-/availability-related terms, not a 1–1 mapping. |
| Buyer | 3002 | `ktddecv:Party` (via `buyerParty`) | `ktddecv:buyerParty` → `ktddecv:Party` (with `ktddecv:name`, `ktddecv:partyAddress`) | `gs1:Organization` (class) + `gs1:organizationRole` pointing to e.g. `gs1:OrganizationRoleType-ORDERING_PARTY` (“Ordering Organization”). | **Strong, but pattern-based** – good conceptual alignment: KTDDE “buyer party” ≈ GS1 Organization with role ORDERING_PARTY. Not a single equivalent property, but a clear mapping pattern. |
| Invoicee | 3006 | `ktddecv:Party` (via `invoiceeParty`) | `ktddecv:invoiceeParty` | `gs1:Organization` + `gs1:organizationRole` with `gs1:OrganizationRoleType-INVOICEE` (“Invoicee”). | **Strong, pattern-based** – there is an exact GS1 role individual for Invoicee. Good candidate for role alignment (KTDDE role vs GS1 OrganizationRoleType). |
| Ship to / Delivery Party | 3144 | `ktddecv:Party` (via `deliveryParty`) | `ktddecv:deliveryParty` | `gs1:Organization` + `gs1:organizationRole` with e.g. `gs1:OrganizationRoleType-DELIVERY_RECIPIENT_PARTY` (“Delivery Recipient Organization”) or SHIP_TO-type roles. | **Strong, pattern-based** – again a very clear conceptual match via GS1 organization roles. |
| Seller | 3346 | `ktddecv:Party` (via `sellerParty`) | `ktddecv:sellerParty` | `gs1:Organization` + `gs1:organizationRole` with `gs1:OrganizationRoleType-SELLER` and/or property `gs1:seller` where relevant. | **Strong, pattern-based** – direct GS1 role “Seller”; fits nicely with KTDDE sellerParty. |
| Place of the delivery of the goods (by the carrier) | 3000 | `ktddecv:TradeDeliveryTerms` → `ktddecv:deliveryLocation` → `ktddecv:Location` | `ktddecv:deliveryLocation` (class `ktddecv:Location`) | `gs1:location` (object property, “Has Location”) with domain `gs1:Offer`, plus GLN/location structures like `gs1:LocationID_Details`, `gs1:LocationRoleType-SHIP_TO_LOCATION`. | **Close** – location semantics are very similar; KTDDE `Location` is a good conceptual peer of GS1’s GLN-based location descriptions, but you would need to agree on GLN/codelists (e.g. add a GLN property in KTDDE). |
| Origin country | 3238 | `ktddecv:GoodsItem` → `ktddecv:hasCountryOfOrigin` → `ktddecv:Country` | `ktddecv:hasCountryOfOrigin`; `ktddecv:Country` with `ktddecv:name` | `gs1:countryOfOrigin` (object property, domain `gs1:Product`, range `gs1:Country`), `gs1:Country` (class), and `gs1:countryCode` (ISO 3166 code). | **Very strong** – `ktddecv:Country` ↔ `gs1:Country` is a good candidate for `owl:equivalentClass`; `ktddecv:hasCountryOfOrigin` ≈ `gs1:countryOfOrigin`. You may want to add an ISO 3166 code property in KTDDE to align with `gs1:countryCode`. |
| Payment term | 4277 | Intended: `ktddecv:PaymentTerms` | (No explicit term yet; only `ktddecv:PaymentTerms` class and `ktddecv:paymentMethod` exist) | `gs1:paymentTerms` (datatype property, “Payment Terms”, domain `gs1:Offer`) | **Design opportunity / close** – KTDDE is missing a “payment terms” property; if you introduce e.g. `ktddecv:paymentTermsCode` or `ktddecv:paymentTermsDescription` on `PaymentTerms`, it can be aligned very cleanly with `gs1:paymentTerms`. |
| Payment Method | 4467 | `ktddecv:PaymentTerms` | `ktddecv:paymentMethod` (datatype) | `gs1:PaymentMethod` (class, “Payment Method Code”) + `gs1:acceptedPaymentMethod` (object property from `gs1:Offer` to `gs1:PaymentMethod`). | **Strong, but level mismatch** – semantics match well: “code indicating a method of payment”. Best practice: constrain `ktddecv:paymentMethod` to use GS1 `PaymentMethod` codes (as values) or model an object property to a PaymentMethod individual. |
| Unit Price | 5110 | `ktddecv:GoodsItem` | `ktddecv:unitPrice` (xsd:decimal) | `gs1:PriceSpecification` (class) with `gs1:price` (numeric amount) and `gs1:priceCurrency` (ISO 4217 code). | **Close** – KTDDE’s `unitPrice` is conceptually the same as GS1’s `price` inside a price specification. You could map `GoodsItem.unitPrice` to a `PriceSpecification` node with `gs1:price` and `gs1:priceCurrency`, or treat `ktddecv:Amount` as a lightweight analogue of `PriceSpecification`. |
| Allowance / Charge | 5189 | `ktddecv:AllowanceCharge` | (Class exists but with no internal properties in SHACL) | GS1 discount/adjustment model: `gs1:Discount` class with properties like `gs1:discountType`, `gs1:exactDiscountAmount`, `gs1:maximumDiscountAmount`, etc. | **Conceptually strong, structurally missing** – KTDDE clearly anticipates an allowance/charge structure. You can model it similarly to GS1 `Discount` / price adjustments and then define close mappings (`AllowanceCharge.amount` ↔ `gs1:exactDiscountAmount`, a type code ↔ `gs1:DiscountTypeCode`, etc.). |
| Order amount | 5390 | `ktddecv:PurchaseOrder` → `ktddecv:orderAmount` → `ktddecv:Amount` | `ktddecv:orderAmount` (object property to `Amount`, which has `ktddecv:value`, `ktddecv:currencyCode`) | `gs1:PriceSpecification` + `gs1:price` and `gs1:priceCurrency` (total / per-offer price). | **Close** – KTDDE `Amount` is a natural analogue for GS1 `PriceSpecification`. You can map `Amount.value` ↔ `gs1:price` and `Amount.currencyCode` ↔ `gs1:priceCurrency`. Whether it is “total order amount” or line price is a modelling decision. |
| Tax amount | 5490 | (not yet explicitly modelled; would sit on PO or a tax sub-structure) | (no `ktddecv:taxAmount` yet) | `gs1:dutyFeeTaxAmount` (datatype property, “Duty Fee Tax Amount”, domain `gs1:PriceSpecification`). | **Design opportunity / close** – if you introduce `ktddecv:taxAmount` (likely as an `Amount`), it aligns well with `gs1:dutyFeeTaxAmount`. Again you can reuse `Amount.value` + `Amount.currencyCode` to mirror the GS1 pattern. |
| Quantity ordered | 6024 | Intended: `ktddecv:GoodsItem` | (no quantity property yet; only `productIdentifier`, `unitPrice`, `hasCountryOfOrigin`, `descriptionOfGoods`) | `gs1:eligibleQuantity` / `gs1:eligibleQuantityMinimum` (quantity to which a price/offer applies). | **Approximate** – GS1’s focus is on “eligible quantity” for an offer rather than ordered quantity in an order document. If you add `ktddecv:orderedQuantity` on `GoodsItem`, you can still use the same numeric/value+unit pattern as GS1, but it is not a strict semantic equivalent. |
| Product identifier | 7135 | `ktddecv:GoodsItem` | `ktddecv:productIdentifier` | `gs1:gtin` (datatype property, “GTIN”, domain `gs1:Product` and `schema:Product`) and potentially additional ID properties (e.g. SKU, if you introduce such differentiation in KTDDE). | **Very strong** – if `productIdentifier` carries a GTIN, you can treat it as a direct mapping to `gs1:gtin` (good candidate for `owl:equivalentProperty` in a GTIN-only profile). If KTDDE allows other ID types, then the mapping is conditional (“when type=GTIN”). |

